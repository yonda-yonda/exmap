{"version":3,"file":"142-f9e373e87eac20d1c14a.js","mappings":"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","sources":["webpack://exmap/./node_modules/ol/node_modules/geotiff/dist-module/predictor.js","webpack://exmap/./node_modules/ol/node_modules/geotiff/dist-module/compression/basedecoder.js","webpack://exmap/./node_modules/ol/node_modules/geotiff/dist-module/compression/packbits.js"],"sourcesContent":["function decodeRowAcc(row, stride) {\n  var length = row.length - stride;\n  var offset = 0;\n\n  do {\n    for (var i = stride; i > 0; i--) {\n      row[offset + stride] += row[offset];\n      offset++;\n    }\n\n    length -= stride;\n  } while (length > 0);\n}\n\nfunction decodeRowFloatingPoint(row, stride, bytesPerSample) {\n  var index = 0;\n  var count = row.length;\n  var wc = count / bytesPerSample;\n\n  while (count > stride) {\n    for (var i = stride; i > 0; --i) {\n      row[index + stride] += row[index];\n      ++index;\n    }\n\n    count -= stride;\n  }\n\n  var copy = row.slice();\n\n  for (var _i = 0; _i < wc; ++_i) {\n    for (var b = 0; b < bytesPerSample; ++b) {\n      row[bytesPerSample * _i + b] = copy[(bytesPerSample - b - 1) * wc + _i];\n    }\n  }\n}\n\nexport function applyPredictor(block, predictor, width, height, bitsPerSample, planarConfiguration) {\n  if (!predictor || predictor === 1) {\n    return block;\n  }\n\n  for (var i = 0; i < bitsPerSample.length; ++i) {\n    if (bitsPerSample[i] % 8 !== 0) {\n      throw new Error('When decoding with predictor, only multiple of 8 bits are supported.');\n    }\n\n    if (bitsPerSample[i] !== bitsPerSample[0]) {\n      throw new Error('When decoding with predictor, all samples must have the same size.');\n    }\n  }\n\n  var bytesPerSample = bitsPerSample[0] / 8;\n  var stride = planarConfiguration === 2 ? 1 : bitsPerSample.length;\n\n  for (var _i2 = 0; _i2 < height; ++_i2) {\n    // Last strip will be truncated if height % stripHeight != 0\n    if (_i2 * stride * width * bytesPerSample >= block.byteLength) {\n      break;\n    }\n\n    var row = void 0;\n\n    if (predictor === 2) {\n      // horizontal prediction\n      switch (bitsPerSample[0]) {\n        case 8:\n          row = new Uint8Array(block, _i2 * stride * width * bytesPerSample, stride * width * bytesPerSample);\n          break;\n\n        case 16:\n          row = new Uint16Array(block, _i2 * stride * width * bytesPerSample, stride * width * bytesPerSample / 2);\n          break;\n\n        case 32:\n          row = new Uint32Array(block, _i2 * stride * width * bytesPerSample, stride * width * bytesPerSample / 4);\n          break;\n\n        default:\n          throw new Error(\"Predictor 2 not allowed with \".concat(bitsPerSample[0], \" bits per sample.\"));\n      }\n\n      decodeRowAcc(row, stride, bytesPerSample);\n    } else if (predictor === 3) {\n      // horizontal floating point\n      row = new Uint8Array(block, _i2 * stride * width * bytesPerSample, stride * width * bytesPerSample);\n      decodeRowFloatingPoint(row, stride, bytesPerSample);\n    }\n  }\n\n  return block;\n}","import _asyncToGenerator from \"/Users/k-yoda/work/sandbox/exmap/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\nimport _classCallCheck from \"/Users/k-yoda/work/sandbox/exmap/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"/Users/k-yoda/work/sandbox/exmap/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport _regeneratorRuntime from \"/Users/k-yoda/work/sandbox/exmap/node_modules/@babel/runtime/regenerator/index.js\";\nimport { applyPredictor } from '../predictor.js';\n\nvar BaseDecoder = /*#__PURE__*/function () {\n  function BaseDecoder() {\n    _classCallCheck(this, BaseDecoder);\n  }\n\n  _createClass(BaseDecoder, [{\n    key: \"decode\",\n    value: function () {\n      var _decode = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(fileDirectory, buffer) {\n        var decoded, predictor, isTiled, tileWidth, tileHeight;\n        return _regeneratorRuntime.wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                _context.next = 2;\n                return this.decodeBlock(buffer);\n\n              case 2:\n                decoded = _context.sent;\n                predictor = fileDirectory.Predictor || 1;\n\n                if (!(predictor !== 1)) {\n                  _context.next = 9;\n                  break;\n                }\n\n                isTiled = !fileDirectory.StripOffsets;\n                tileWidth = isTiled ? fileDirectory.TileWidth : fileDirectory.ImageWidth;\n                tileHeight = isTiled ? fileDirectory.TileLength : fileDirectory.RowsPerStrip || fileDirectory.ImageLength;\n                return _context.abrupt(\"return\", applyPredictor(decoded, predictor, tileWidth, tileHeight, fileDirectory.BitsPerSample, fileDirectory.PlanarConfiguration));\n\n              case 9:\n                return _context.abrupt(\"return\", decoded);\n\n              case 10:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee, this);\n      }));\n\n      function decode(_x, _x2) {\n        return _decode.apply(this, arguments);\n      }\n\n      return decode;\n    }()\n  }]);\n\n  return BaseDecoder;\n}();\n\nexport { BaseDecoder as default };","import _classCallCheck from \"/Users/k-yoda/work/sandbox/exmap/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"/Users/k-yoda/work/sandbox/exmap/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport _inherits from \"/Users/k-yoda/work/sandbox/exmap/node_modules/@babel/runtime/helpers/esm/inherits.js\";\nimport _possibleConstructorReturn from \"/Users/k-yoda/work/sandbox/exmap/node_modules/@babel/runtime/helpers/esm/possibleConstructorReturn.js\";\nimport _getPrototypeOf from \"/Users/k-yoda/work/sandbox/exmap/node_modules/@babel/runtime/helpers/esm/getPrototypeOf.js\";\n\nfunction _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\n\nfunction _isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }\n\nimport BaseDecoder from './basedecoder.js';\n\nvar PackbitsDecoder = /*#__PURE__*/function (_BaseDecoder) {\n  _inherits(PackbitsDecoder, _BaseDecoder);\n\n  var _super = _createSuper(PackbitsDecoder);\n\n  function PackbitsDecoder() {\n    _classCallCheck(this, PackbitsDecoder);\n\n    return _super.apply(this, arguments);\n  }\n\n  _createClass(PackbitsDecoder, [{\n    key: \"decodeBlock\",\n    value: function decodeBlock(buffer) {\n      var dataView = new DataView(buffer);\n      var out = [];\n\n      for (var i = 0; i < buffer.byteLength; ++i) {\n        var header = dataView.getInt8(i);\n\n        if (header < 0) {\n          var next = dataView.getUint8(i + 1);\n          header = -header;\n\n          for (var j = 0; j <= header; ++j) {\n            out.push(next);\n          }\n\n          i += 1;\n        } else {\n          for (var _j = 0; _j <= header; ++_j) {\n            out.push(dataView.getUint8(i + _j + 1));\n          }\n\n          i += header + 1;\n        }\n      }\n\n      return new Uint8Array(out).buffer;\n    }\n  }]);\n\n  return PackbitsDecoder;\n}(BaseDecoder);\n\nexport { PackbitsDecoder as default };"],"names":["decodeRowAcc","row","stride","length","offset","i","decodeRowFloatingPoint","bytesPerSample","index","count","wc","copy","slice","_i","b","applyPredictor","block","predictor","width","height","bitsPerSample","planarConfiguration","Error","_i2","byteLength","Uint8Array","Uint16Array","Uint32Array","concat","BaseDecoder","this","_decode","key","value","_callee","fileDirectory","buffer","decoded","isTiled","tileWidth","tileHeight","_context","prev","next","decodeBlock","sent","Predictor","StripOffsets","TileWidth","ImageWidth","TileLength","RowsPerStrip","ImageLength","abrupt","BitsPerSample","PlanarConfiguration","stop","_x","_x2","apply","arguments","_createSuper","Derived","hasNativeReflectConstruct","Reflect","construct","sham","Proxy","Boolean","prototype","valueOf","call","e","_isNativeReflectConstruct","result","Super","NewTarget","constructor","PackbitsDecoder","_BaseDecoder","_super","dataView","DataView","out","header","getInt8","getUint8","j","push","_j"],"sourceRoot":""}